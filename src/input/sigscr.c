/*
 *==============================================================================
 *345678901234567890123456789012345678901234567890123456789012345678901234567890
 *
 *   File:  sigscr.c
 *   Copyright 2022  David J. Webb
 *
 *   File contains subroutines for processing the signal script trees
 *   generated by the bison program.  This file is compiled separately
 *
 *   Released under licence GPL-3.0-or-later
 *
 *   ZR is free software: you can redistribute it and/or modify
 *   it under the terms of the GNU General Public License as published by
 *   the Free Software Foundation, either version 3 of the License, or
 *   (at your option) any later version.
 *
 *   ZR is distributed in the hope that it will be useful,
 *   but WITHOUT ANY WARRANTY; without even the implied warranty of
 *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 *   GNU General Public License for more details.
 *
 *   You should have received a copy of the GNU General Public License
 *   along with ZR.  If not, see <https://www.gnu.org/licenses/>.
 *
 *==============================================================================
 */

#include <stdio.h>
#include <stdlib.h>
#include <stdarg.h>
#include <string.h>
#include "sigscr.h"
#include "y.tab.h"

/*
 *   This array should match the array 'yytname' in file "y.tab.c", starting
 *   with item 'SC_PROGRAM' in that array end and ending with item 'SC_POW'.
 *   Note in all the signal script code, 'SC_' is added to the standard names
 *   to prevent conflicts with other names used by MSTS, OpenRails and ZR.
 */
#if 1
static char *token[] = {
    "SC_PROGRAM",
    "SC_FUNCTION",
    "SC_VARIABLE",
    "SC_NAME",
    "SC_IVALUE",
    "SC_FVALUE",
    "SC_SCRIPT",
    "SC_EXTERN",
    "SC_FLOAT",
    "SC_IF",
    "SC_ELSE",
    "SC_FOR",
    "SC_WHILE",
    "SC_DO",
    "SC_BREAK",
    "SC_CONTINUE",
    "SC_RETURN",
    "SC_PRINT",
    "SC_UMINUS",
    "SC_SCRIPT_LIST",
    "SC_DEF_LIST",
    "SC_STMT_LIST",
    "SC_DEF_EFUN",
    "SC_DEF_EVAR",
    "SC_DEF_VAR",
    "SC_EXIT",
    "SC_ASSIGN", "SC_IAS",
    "SC_PE", "SC_ME", "SC_XE", "SC_DE",
    "SC_IASD", "SC_AMD", "SC_IFX",
    "SC_BB",
    "SC_NO_OP",
    "SC_NEG",
    "SC_COMMA",
    "SC_EXPR_LIST",
    "SC_AND", "SC_OR", "SC_EOR", "SC_NOT", "SC_INT",
    "SC_GT", "SC_LT", "SC_GE", "SC_LE", "SC_EQ", "SC_NE",
    "SC_IGT", "SC_ILT", "SC_IGE", "SC_ILE", "SC_IEQ", "SC_INE",
    "SC_POW"
} ;
#endif

extern int       yydebug ;
extern nodeType  *sTree  ;               //  Defined in zr.h

int    print_sigscr_node(nodeType *p)   ;
int    yyparse(nodeType **sTree) ;
void   yyset_in(FILE *sfile)     ;

extern FILE   *yyin, *yyout ;
int    itree_depth   ;

/*
 *  Routine to read signal script file and initialise the tree pointer sTree.
 */
int read_sigscr_file(char *or_route_dir, char *script_file){

  int  ip = 0 ;
  int  l, iret ;
  char *string = NULL,
       *my_name = "read_sigscr_file" ;

      if(ip)printf("  Enter routine %s\n",my_name) ;
      yydebug = 0 ;

/*
 *  The file sigcfg.dat should be in the main "Route" directory (ORRoutedir))
 */
      l = strlen(or_route_dir) + strlen(script_file) + 1;
      string = (char *) malloc(l) ;
      strcpy(string,or_route_dir) ;
      strcat(string,script_file)  ;
/*
 *  Check file exists
 */
      if(ip)printf("  Routine %s.  Opening file %s\n",my_name,string) ;
      yyin = fopen(string,"r") ;
      if(yyin == NULL){
        printf("  Unable to find sigscr.dat file\n") ;
        printf("     Full filename = %s\n",string) ;
        printf("  Program stopping ...\n") ;
        exit(1) ;
      }
      printf("     File opened : %s\n",string) ;
      free(string) ;
/*
 *   Parse file
 */
      yyset_in(yyin) ;
      iret = yyparse(&sTree);
      if(iret){
        printf("  Unable to parse signal script file\n");
        printf("  Error return value = %i\n",iret);
        exit(0) ;
      }
      if(ip)printf("  Close file \n") ;
      fclose(yyin);
/*
 *  Print summary
 */
      if(ip){
        printf("  sTree = %p\n",(void *)sTree) ;
        printf("  sTree->type = %i\n",sTree->type) ;
        printf("  sTree->opr.oper = %i\n",sTree->opr.oper) ;
        printf("  sTree->opr.nops = %i\n",sTree->opr.nops) ;

        printf("\n PRINT TREE\n") ;
        print_sigscr_node(sTree) ;
      }

      return 0 ;
}

int print_sigscr_node(nodeType *p){

int i, n, nops, oper, type, n1, n2 ;

      if(p == NULL) return 0 ;
      type = p->type ;
#if 0
      if(itree_depth){
        for(i=0;i<itree_depth;i++)printf("  ") ;
      }
      printf("  ENTER  print_sigscr_node\n") ;
      if(itree_depth){
        for(i=0;i<itree_depth;i++)printf("  ") ;
      }
      printf("  psn :: p       = %p\n",(void *)p) ;
      if(itree_depth){
        for(i=0;i<itree_depth;i++)printf("  ") ;
      }
      printf("  psn :: p->type = %i\n",type)      ;
      if(itree_depth){
        for(i=0;i<itree_depth;i++)printf("  ") ;
      }
#endif
      if(type == typeStr){
        for(i=0;i<itree_depth;i++)printf("  ") ;
        printf("  psn : str :: name = %s\n",p->str.name) ;
      }else if( type == typeOpr){
        oper = p->opr.oper ;
        nops = p->opr.nops ;
        for(i=0;i<itree_depth;i++)printf("  ") ;
        if(oper >= SC_PROGRAM && oper <= SC_POW){
          i = oper-SC_PROGRAM ;
          printf("  psn : opr :: %i %i %s\n",nops,oper,token[i]);
        }else{
          printf("  psn : opr :: %i %i %s\n",nops,oper,"INDEX OUT OF RANGE");
        }
        itree_depth++ ;
        for(n=0;n<nops;n++){
#if 0
          for(i=0;i<itree_depth;i++)printf("  ") ;
          printf("  psn : opr :: index = %i\n",n) ;
#endif
          print_sigscr_node(p->opr.op[n]);
        }
        itree_depth-- ;
      }else{
        printf(" ERROR in routine print_sigscr_node\n");
        printf(" psn ::     type = %i\n",type) ;
        exit(0) ;
      }
      return 0 ;
}

int print_sigscr_tree(nodeType *p){

      printf("  ENTER  print_sigscr_tree\n") ;
      printf("  pst ::       p   = %p\n",(void *)p) ;
      itree_depth = 0 ;
      print_sigscr_node(p) ;
      return 0 ;
}

/*
 *  Routine to return the character string corresponding to a
 *  script token.
 */

char *sigscr_token_string(int i){

      if(i < SC_PROGRAM && i > SC_POW) return NULL ;
      return token[i-SC_PROGRAM] ;
}
