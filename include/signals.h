/*
 *******************************************************************************
 *345678901234567890123456789012345678901234567890123456789012345678901234567890
 *
 *   File signals.h
 *
 *   This file is part of ZR. Released under licence GPL-3.0-or-later.
 *   You should have received a copy of the GNU General Public License
 *   along with ZR.  If not, see <https://www.gnu.org/licenses/>.
 *
 *   This file contains data structures used for the signal database.
 *
 * *****************************************************************************
 *
 *   Notes on "sigcfg.dat"
 *
 *   MSTS has files sigcfg.dat and sigdcr.dat in each Routes directory.
 *     File sigcfg.dat describes each of the signals.
 *     File sigscr.dat contains scripts/mini-programs needed to set each
 *       set of signals
 *
 *   The file "sigcfg.data" is (usually?) an uncompressed text file.  It is
 *   initially opened using routine ?? to strip the headers, if necessary
 *   uncompress the file, and set flags for reading using teh routines in
 *   file "token.c".
 *
 *   The data is read and saved in "SignalDB" structure "signal_db".  The
 *   structure is defined in "signals.h", the database is defined in "zr.h".
 *
 *   NOTE:  There are a number of fields (i.e. Approach Control Limits) which
 *          this routine does not handle.
 *
 * *****************************************************************************
 */
typedef struct rawsignaldb RawSignalDB ;
typedef struct lighttex    LightTex  ;
typedef struct lighttab    LightTab  ;
typedef struct sigtype     SigType   ;
typedef struct siglight    SigLight  ;
typedef struct sigdraw     SigDraw   ;
typedef struct sigaspect   SigAspect ;
typedef struct sigshape    SigShape  ;
typedef struct sigsubobj   SigSubObj  ;
typedef struct sigscriptfile  SigScriptFile ;

//typedef struct signaldb    SignalDB  ;  Defined in typedef.h

/*
 *  Note 'state' is the value of 'aspect' generated by the signal scripts
 *  At some stage I need to combine the two.
 *
 *  'draw_state' appears to be the state drawn based on the 'state'/'aspect'
 *  and the actual lights and semaphore arm carried by the physical signal.
 */

struct signaldb {
  SignalDB    *next        ;
  int         uid          ;
  char        *shape_name  ;
  char        *type_name   ;
  char        *world_name  ;
  WorldItem   *witem       ;  // World item signal structure containing this signal
  SignalObj   *sig_object  ;  // Signal data saved with world item
  int         sig_obj_i    ;  // Index of this signal in signal_object arrays
  TrkItem     *trk_item    ;  // Track item linked to this signal
  int         sig_shape_i  ;  // Index of signal shape in signal_type_array
  int         sig_subobj_i ;  // Index of signal shape sub-object
  int         sig_type_i   ;  // Index of signal type in signal shape array
  SigShape    *sig_shape   ;  // Signal Shape node describing this signal
  SigSubObj   *sig_subobj  ;  // Signal Shape Sub-node describing this signal
  SigType     *sig_type    ;  // Raw signal node describing this signal
  nodeType    *sig_script  ;  // Root of script for this signal
  int         enabled      ;  // Option to disable signal ??
  int         state        ;  //  MSTS Signal Aspect : STOP, CLEAR_1, etc
  int         draw_state   ;  //  Openrails: def_draw_state(state)
  int         aspect       ;  // State shown by signal : STOP, CLEAR_2 etc
  double      semaphore_pos;  // Current semaphore position : 0.0 to 1.0
  double      light_pos    ;  // Current light state : 0.0 to 1.0
} ;

struct rawsignaldb {

  int temp ;
  int       n_light_tex   ;   //  Should be 1
  int       n_light_tab   ;
  int       n_sig_types   ;
  int       n_sig_shapes  ;
  int       n_scripts     ;

  LightTex  *light_tex    ;
  LightTab  *light_tab    ;
  SigType   *sig_type     ;
  SigShape  *sig_shape    ;
  SigScriptFile *script_file  ;
} ;

/*
 *  Defines a single light texture, used as background to draw lit lights onto signals
 */
struct lighttex {
  LightTex    *next ;
  char        *name     ;  //  Name of the light texture
  char        *ace_file ;  //  Texture filename
  double      flag[4] ;    //  Left, Top, Right, Bottom Co-ordinates of texture
  TextureNode *tnode ;     //  Pointer to texture
} ;

/*
 *  Describes how to draw a light in its illuminated state
 *  On input colours are converted for OpenGL :: int->float, ARGB->RGBA
 */
struct lighttab {
  char  *name     ;
  float colour[4] ;   //  Red, Greeen, Blue, Alpha
} ;

struct sigtype {
  char   *name           ;
  int    msts_function   ;       // MSTS enum :: SIG_NORMAL, SIG_SPEED, ...
  char   *or_function    ;       // OpenRails function type
  int    or_function_index ;
  char   *or_subfunction ;
  int    or_subfunction_index ;
  int    semaphore       ;       // Has semaphore arm
  int    no_gantry       ;       // Not suitable for use on a gantry
  int    abs             ;       // Unknown : Used in Maria Pass Route
  double semaphore_info  ;       //  Number of seconds to abimate a semaphore signal (default=1)
  double sig_flash[2]    ;       // Flash duration on, off
//  Raw Signals refer to a LightTex name, not the actual texture name.
  char        *light_tex_ref  ;  // Reference name of LightTex node
  TextureNode *light_tex_node ;  // Ultimate light texture structure

  int       n_sig_lights  ;
  int       n_sig_dstates ;
  int       n_sig_aspects ;
  SigLight  *sig_light       ; // Signal Light structure
  SigDraw   *sig_draw        ; // Signal Draw States
  SigDraw   *sig_draw_a[8]   ; // Pointers for all 8 possible states
  int       sig_draw_ia[8]   ;
  SigAspect *sig_aspect      ; // Signal Aspects
  SigAspect *sig_aspect_a[8] ; // Pointers for all 8 possible states
  int       sig_aspect_ia[8] ;
  int       n_clear_ahead ;

  nodeType  *sig_script   ;  //  Signal scipt for this type of signal
} ;
/*
 *  Describes the a light on a signal, so the location and size of a signal light,
 *  as well as a reference to a light from the lights table
 */

struct siglight {
  int    index   ;  //  Index in the list of signal lights
  char   *name   ;  //  Name of the reference light from the lights table
  double posn[3] ;  //  X, Y and Z offset (MSTS coords?)
  double radius  ;  //  Radius of the light
  int    semaphore_change ;
  LightTab *light_tab ;  // Pointer to the reference light
} ;

/*
 *  Describes a draw state: a single combination of lights and semaphore arm positions that go together
 */
struct sigdraw {
  int    index            ;  // Index in the list of draw states
  char   *name            ;  //  Name identifying the draw sate
  int    n_draw_lights    ;  //  Number of lights to draw in this draw state
  int    *draw_light_i    ;  //  Indices of lights to draw
  int    semaphore_posn   ;  //  Semaphore position in this draw state
  int    flashing         ;
  SigLight **draw_light   ;  //  Array of Pointers to Signal Light Nodes
} ;
/*
 *  Describes an signal aspect, a combination of a signal indication state and what it means to be in that state.
 */

struct sigaspect {
  int    status           ;  //  enum :: SIG_STOP, SIG_CLEAR_1, ...
  char   *draw_state_name ;  // Name of draw state to use
  double mph              ;  // Speed
  double kph              ;  // Speed
  uint   asap             ;  // Set to true if SignalFlags ASAP option specified, meaning train needs to go to speed As Soon As Possible
//  uint   flags            ;
  int    i_sig_draw       ;  // Index of signal draw state in sig_draw_a[8]
  SigDraw *sig_draw       ;  // Pointer to draw state
} ;

struct sigshape {
  char      *shapefile    ;  //  File describing shape
  char      *name         ;  //  Name of the signal shape
  int       n_sig_subobjs ;
  SigSubObj *sig_subobj   ;  // List of sub-objects that belong to this shape
} ;

/*
 *  A sub-object belonging to a signal shape
 */
struct sigsubobj {
  int  index           ;  // Index of the sub-object 0, 1, 2, ...
  char *name           ;  // Name of the head  HEAD1 or HEAD2 etc
  char *full_name      ;  // "lower dwarf arm" or "upper dwarf arm etc"
  char *sig_script_type ;  // Type in signal script
//  Flags specifying optional properties, 1/0 => absent/present
  int  sig_signal_head ;
  int  sig_gradient_plate ;
  int  sig_number_plate   ;
  int  sig_user1          ;  // Used by AU_NSW_SW_SS route
  int  sig_user2          ;
  int  sig_user3          ;
  int  sig_user4          ;

  int  sig_default     ;
  int  sig_jn_link     ;
  int  sig_back_facing ;
  int  sig_optional    ;

//  The junction link will be different for each junction the signal
//  is used for, so the following should both be zero.
  int  n_sig_jn_lnk    ;  //  Always missing ??
  int  sig_jn_lnk_a[2]   ;  //  Always missing ??
} ;

struct sigscriptfile {
  SigScriptFile *next ;
  char          *scriptfile_name ;
} ;

